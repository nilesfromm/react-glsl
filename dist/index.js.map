{"version":3,"sources":["../src/shader/index.tsx"],"names":["React","useState","useRef","useEffect","useCallback","DEFAULT_ATTRIBUTES","ShaderCanvas","glsl","uniforms","className","enableMouse","enableTime","pixelRatio","style","webglAttributes","mousePos","setMousePos","fragmentShader","vertexShader","gl","setGL","program","canvasRef","canvas","width","height","createShader","shaderSource","type","shader","createProgram","vertex","fragment","triangleArray","resolutionUniformLocation","mouseUniformLocation","positionLocation","vao","positionBuffer","Render","time","uniform","location","timeUniformLocation","getUniformLocation","name","updateMousePosition","e"],"mappings":"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","sourcesContent":["import React, {\n  useState,\n  useRef,\n  RefObject,\n  useMemo,\n  CSSProperties,\n  useEffect,\n  useCallback,\n} from \"react\";\n\ntype uniform = {\n  name: string;\n  value: number | number[];\n};\n\nexport type ShaderCanvasProps = {\n  glsl: string;\n  enableMouse?: boolean;\n  enableTime?: boolean;\n  uniforms?: uniform[];\n  pixelRatio?: number;\n  style?: CSSProperties;\n  className?: string;\n  webglAttributes?: WebGLContextAttributes;\n};\n\ninterface Shaders {\n  readonly vertex: string;\n  readonly fragment: string;\n}\n\nexport type ShaderResult = {\n  id: number;\n  program?: WebGLProgram;\n  ready?: boolean;\n};\n\nconst DEFAULT_ATTRIBUTES: WebGLContextAttributes = {\n  alpha: true,\n  antialias: false,\n  depth: true,\n  desynchronized: true,\n  failIfMajorPerformanceCaveat: undefined,\n  powerPreference: \"default\",\n  premultipliedAlpha: true,\n  preserveDrawingBuffer: false,\n  stencil: false,\n};\n\nexport const ShaderCanvas = ({\n  glsl,\n  uniforms = [],\n  className = \"\",\n  enableMouse = true,\n  enableTime = true,\n  pixelRatio = 1,\n  style = {},\n  webglAttributes = DEFAULT_ATTRIBUTES,\n}: ShaderCanvasProps): JSX.Element => {\n  const [mousePos, setMousePos] = useState({ x: 0.5, y: 0.5 });\n  const fragmentShader = glsl;\n  const vertexShader = `#version 300 es\n    in vec4 a_position;\n    void main() {\n      gl_Position = a_position;\n    }\n  `;\n\n  const [gl, setGL] = useState<WebGL2RenderingContext | null>();\n  const program = useRef<WebGLProgram | null>();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      setGL(\n        canvas.getContext?.(\"webgl2\", {\n          ...webglAttributes,\n        })\n      );\n      const width = canvas.clientWidth | 0;\n      const height = canvas.clientHeight | 0;\n      if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n      }\n    }\n  }, [canvasRef]);\n\n  const createShader = useCallback(\n    (shaderSource: string, type: GLenum) => {\n      if (!gl) {\n        return;\n      }\n      if (type !== gl.VERTEX_SHADER && type !== gl.FRAGMENT_SHADER) {\n        throw new Error(`Shader Type error`);\n      }\n      const shader = gl.createShader(type);\n      if (!shader) {\n        throw new Error(`Shader Generation error`);\n      }\n      gl.shaderSource(shader, shaderSource);\n      gl.compileShader(shader);\n\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(`Shader Compile error: ` + gl.getShaderInfoLog(shader));\n      }\n      return shader;\n    },\n    [gl]\n  );\n\n  const createProgram = useCallback(\n    ({ vertex, fragment }: Shaders): ShaderResult | undefined => {\n      if (!gl) {\n        return;\n      }\n      program.current = gl.createProgram();\n      if (!program.current) {\n        throw new Error(`Unable to create program.`);\n      }\n\n      const vertexShader = createShader(vertex, gl.VERTEX_SHADER)!;\n      const fragmentShader = createShader(fragment, gl.FRAGMENT_SHADER)!;\n      gl.attachShader(program.current, vertexShader);\n      gl.attachShader(program.current, fragmentShader);\n      gl.linkProgram(program.current);\n\n      if (!gl.getProgramParameter(program.current, gl.LINK_STATUS)) {\n        gl.detachShader(program.current, vertexShader);\n        gl.detachShader(program.current, fragmentShader);\n        gl.deleteShader(vertexShader);\n        gl.deleteShader(fragmentShader);\n        throw new Error(\n          \"Unable to initialize the shader program:\\n\" +\n            gl.getProgramInfoLog(program.current)\n        );\n      }\n\n      const triangleArray = gl.createVertexArray();\n      gl.bindVertexArray(triangleArray);\n\n      // uniforms.forEach((uniform) => {\n      //   const location = gl.getUniformLocation(program.current, uniform.name);\n      //   if (!location) {\n      //     throw new Error(`Unable to get uniform location for ${uniform.name}`);\n      //   }\n      //   switch (uniform.type) {\n      //     case \"float\":\n      //       gl.uniform1f(location, uniform.value as number);\n      //       break;\n      //     case \"vec2\":\n      //       gl.uniform2fv(location, uniform.value as number[]);\n      //       break;\n      //     case \"vec3\":\n      //       gl.uniform3fv(location, uniform.value as number[]);\n      //       break;\n      //     case \"vec4\":\n      //       gl.uniform4fv(location, uniform.value as number[]);\n      //       break;\n      //   }\n      // });\n\n      // const sliderUniformLocation = gl.getUniformLocation(\n      //   program.current,\n      //   \"slider\"\n      // );\n\n      const resolutionUniformLocation = gl.getUniformLocation(\n        program.current,\n        \"resolution\"\n      );\n      const mouseUniformLocation = gl.getUniformLocation(\n        program.current,\n        \"mouse\"\n      );\n      const positionLocation = gl.getAttribLocation(\n        program.current,\n        \"a_position\"\n      );\n\n      if (positionLocation >= 0) {\n        var vao = gl.createVertexArray();\n        gl.bindVertexArray(vao);\n        const positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n        gl.bufferData(\n          gl.ARRAY_BUFFER,\n          new Float32Array([\n            -1,\n            -1, // first triangle\n            1,\n            -1,\n            -1,\n            1,\n            -1,\n            1, // second triangle\n            1,\n            -1,\n            1,\n            1,\n          ]),\n          gl.STATIC_DRAW\n        );\n\n        gl.enableVertexAttribArray(positionLocation);\n        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.clearColor(0, 0, 0, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        gl.useProgram(program.current);\n        gl.uniform2f(\n          resolutionUniformLocation,\n          gl.canvas.width,\n          gl.canvas.height\n        );\n        gl.uniform2f(mouseUniformLocation, mousePos.x, mousePos.y);\n        gl.bindVertexArray(vao);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n      }\n    },\n    [createShader, gl, mousePos]\n  );\n\n  const Render = (time: number) => {\n    if (!gl || !program.current || !enableTime) {\n      return;\n    }\n\n    uniforms.forEach((uniform) => {\n      if (!program.current) return;\n      const location = gl.getUniformLocation(program.current, uniform.name);\n      if (!location) {\n        throw new Error(`Unable to get uniform location for ${uniform.name}`);\n      }\n      if (typeof uniform.value === \"number\") {\n        gl.uniform1f(location, uniform.value as number);\n      } else if (uniform.value.length === 2) {\n        gl.uniform2fv(location, uniform.value as number[]);\n      } else if (uniform.value.length === 3) {\n        gl.uniform3fv(location, uniform.value as number[]);\n      } else if (uniform.value.length === 4) {\n        gl.uniform4fv(location, uniform.value as number[]);\n      }\n    });\n\n    time *= 0.001; // convert to seconds\n    const mouseUniformLocation = gl.getUniformLocation(\n      program.current,\n      \"mouse\"\n    );\n    const timeUniformLocation = gl.getUniformLocation(program.current, \"time\");\n    gl.uniform2f(mouseUniformLocation, mousePos.x, mousePos.y);\n    gl.uniform1f(timeUniformLocation, time);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    requestAnimationFrame(Render);\n  };\n  requestAnimationFrame(Render);\n\n  const getUniformLocation = useCallback(\n    (name: string): WebGLUniformLocation | undefined => {\n      if (gl && program.current) {\n        return gl.getUniformLocation(program.current, name) ?? undefined;\n      }\n      return;\n    },\n    [gl, program]\n  );\n\n  useEffect(() => {\n    if (!gl || !vertexShader || !fragmentShader) {\n      return;\n    }\n    createProgram({ vertex: vertexShader, fragment: fragmentShader });\n  }, [gl, vertexShader, fragmentShader, createProgram]);\n\n  const updateMousePosition = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      const canvas = e.target as HTMLCanvasElement;\n      enableMouse &&\n        setMousePos({\n          x: e.nativeEvent.offsetX / canvas.offsetWidth,\n          y: 1 - e.nativeEvent.offsetY / canvas.offsetHeight,\n        });\n    },\n    [mousePos]\n  );\n\n  return (\n    <canvas\n      ref={canvasRef}\n      onMouseMove={(e) => updateMousePosition(e)}\n      className={className}\n      style={{\n        width: \"100%\",\n        height: \"100%\",\n        ...style,\n      }}\n    ></canvas>\n  );\n};\n"]}