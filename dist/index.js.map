{"version":3,"sources":["../src/shader/index.tsx"],"names":["useState","useRef","useEffect","useCallback","jsx","DEFAULT_ATTRIBUTES","ShaderCanvas","props","glsl","uniforms","style","mousePos","setMousePos","fragmentShader","vertexShader","gl","setGL","program","canvasRef","canvas","width","height","createShader","shaderSource","type","shader","createProgram","vertex","fragment","triangleArray","resolutionUniformLocation","mouseUniformLocation","positionLocation","vao","positionBuffer","Render","time","timeUniformLocation","getUniformLocation","name","updateMousePosition","e"],"mappings":"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","sourcesContent":["import React, {\n  useState,\n  useRef,\n  RefObject,\n  useMemo,\n  CSSProperties,\n  useEffect,\n  useCallback,\n} from \"react\";\n\nexport interface ShaderCanvasProps {\n  glsl: string;\n  uniforms?: string;\n  mouse?: boolean;\n  time?: boolean;\n  pixelRatio?: number;\n  style?: CSSProperties;\n  webglAttributes?: WebGLContextAttributes;\n}\n\ninterface Shaders {\n  readonly vertex: string;\n  readonly fragment: string;\n}\n\nexport interface ShaderResult {\n  id: number;\n  program?: WebGLProgram;\n  ready?: boolean;\n}\n\nconst DEFAULT_ATTRIBUTES: WebGLContextAttributes = {\n  alpha: true,\n  antialias: false,\n  depth: true,\n  desynchronized: true,\n  failIfMajorPerformanceCaveat: undefined,\n  powerPreference: \"default\",\n  premultipliedAlpha: true,\n  preserveDrawingBuffer: false,\n  stencil: false,\n};\n\nexport function ShaderCanvas(props: ShaderCanvasProps): JSX.Element {\n  const { glsl, uniforms, style } = props;\n  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });\n  const fragmentShader = glsl;\n  const vertexShader = `#version 300 es\n    in vec4 a_position;\n    void main() {\n      gl_Position = a_position;\n    }\n  `;\n\n  const [gl, setGL] = useState<WebGL2RenderingContext | null>();\n  const program = useRef<WebGLProgram | null>();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (canvas) {\n      setGL(\n        canvas.getContext?.(\"webgl2\", {\n          ...DEFAULT_ATTRIBUTES,\n        })\n      );\n      const width = canvas.clientWidth | 0;\n      const height = canvas.clientHeight | 0;\n      if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n      }\n    }\n  }, [canvasRef]);\n\n  const createShader = useCallback(\n    (shaderSource: string, type: GLenum) => {\n      if (!gl) {\n        return;\n      }\n      if (type !== gl.VERTEX_SHADER && type !== gl.FRAGMENT_SHADER) {\n        throw new Error(`Shader Type error`);\n      }\n      const shader = gl.createShader(type);\n      if (!shader) {\n        throw new Error(`Shader Generation error`);\n      }\n      gl.shaderSource(shader, shaderSource);\n      gl.compileShader(shader);\n\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(`Shader Compile error: ` + gl.getShaderInfoLog(shader));\n      }\n      return shader;\n    },\n    [gl]\n  );\n\n  const createProgram = useCallback(\n    ({ vertex, fragment }: Shaders): ShaderResult | undefined => {\n      if (!gl) {\n        return;\n      }\n      program.current = gl.createProgram();\n      if (!program.current) {\n        throw new Error(`Unable to create program.`);\n      }\n\n      const vertexShader = createShader(vertex, gl.VERTEX_SHADER)!;\n      const fragmentShader = createShader(fragment, gl.FRAGMENT_SHADER)!;\n      gl.attachShader(program.current, vertexShader);\n      gl.attachShader(program.current, fragmentShader);\n      gl.linkProgram(program.current);\n\n      if (!gl.getProgramParameter(program.current, gl.LINK_STATUS)) {\n        gl.detachShader(program.current, vertexShader);\n        gl.detachShader(program.current, fragmentShader);\n        gl.deleteShader(vertexShader);\n        gl.deleteShader(fragmentShader);\n        throw new Error(\n          \"Unable to initialize the shader program:\\n\" +\n            gl.getProgramInfoLog(program.current)\n        );\n      }\n\n      const triangleArray = gl.createVertexArray();\n      gl.bindVertexArray(triangleArray);\n\n      const resolutionUniformLocation = gl.getUniformLocation(\n        program.current,\n        \"resolution\"\n      );\n      const mouseUniformLocation = gl.getUniformLocation(\n        program.current,\n        \"mouse\"\n      );\n      const positionLocation = gl.getAttribLocation(\n        program.current,\n        \"a_position\"\n      );\n\n      if (positionLocation >= 0) {\n        var vao = gl.createVertexArray();\n        gl.bindVertexArray(vao);\n        const positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n        gl.bufferData(\n          gl.ARRAY_BUFFER,\n          new Float32Array([\n            -1,\n            -1, // first triangle\n            1,\n            -1,\n            -1,\n            1,\n            -1,\n            1, // second triangle\n            1,\n            -1,\n            1,\n            1,\n          ]),\n          gl.STATIC_DRAW\n        );\n\n        gl.enableVertexAttribArray(positionLocation);\n        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        gl.clearColor(0, 0, 0, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        gl.useProgram(program.current);\n        gl.uniform2f(\n          resolutionUniformLocation,\n          gl.canvas.width,\n          gl.canvas.height\n        );\n        gl.uniform2f(mouseUniformLocation, mousePos.x, mousePos.y);\n        gl.bindVertexArray(vao);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n      }\n    },\n    [createShader, gl, mousePos]\n  );\n\n  const Render = (time: number) => {\n    if (!gl || !program.current) {\n      return;\n    }\n    time *= 0.001; // convert to seconds\n    const mouseUniformLocation = gl.getUniformLocation(\n      program.current,\n      \"mouse\"\n    );\n    const timeUniformLocation = gl.getUniformLocation(program.current, \"time\");\n    gl.uniform2f(mouseUniformLocation, mousePos.x, mousePos.y);\n    gl.uniform1f(timeUniformLocation, time);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    requestAnimationFrame(Render);\n  };\n  requestAnimationFrame(Render);\n\n  const getUniformLocation = useCallback(\n    (name: string): WebGLUniformLocation | undefined => {\n      if (gl && program.current) {\n        return gl.getUniformLocation(program.current, name) ?? undefined;\n      }\n      return;\n    },\n    [gl, program]\n  );\n\n  useEffect(() => {\n    if (!gl || !vertexShader || !fragmentShader) {\n      return;\n    }\n    createProgram({ vertex: vertexShader, fragment: fragmentShader });\n  }, [gl, vertexShader, fragmentShader, createProgram]);\n\n  const updateMousePosition = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement, MouseEvent>) => {\n      const canvas = e.target as HTMLCanvasElement;\n      setMousePos({\n        x: e.nativeEvent.offsetX / canvas.offsetWidth,\n        y: 1 - e.nativeEvent.offsetY / canvas.offsetHeight,\n      });\n    },\n    [mousePos]\n  );\n\n  return (\n    <canvas\n      ref={canvasRef}\n      // width={width}\n      // height={height}\n      onMouseMove={(e) => updateMousePosition(e)}\n      style={{\n        width: \"100%\",\n        height: \"100%\",\n        ...style,\n      }}\n    ></canvas>\n  );\n}\n"]}